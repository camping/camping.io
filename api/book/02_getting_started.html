<!DOCTYPE html>
<html>
<head>
  <title>Camping, a Microframework</title>
	<link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />
  <script src="../js/jquery.js" type="text/javascript"></script>
  <script src="../js/camping.js" type="text/javascript"></script>
</head>
<body>
  <div id="menu">
    <ul id="links">
      <li><a href="/">front</a> | </li>
      <li><a href="../book.html">ToC</a> | </li>
      <li><a href="../">reference</a> | </li>
      <li><a href="http://wiki.github.com/camping/camping">wiki</a> | </li>
      <li><a href="http://github.com/camping/camping">code</a></li>
    </ul>
    <p id="version">Camping 2.1.414</p>
  </div>
  
  <div id="fullpage">
    <div class="page_shade">
    	<div class="page">
    	  <p class="header">Thu Aug 19 16:07:44 +0200 2010</p>
        <h1>Getting Started</h1>
<p>
Start a new text file called nuts.rb. Here&#8217;s what you put inside:
</p>
<pre>
  Camping.goes :Nuts
</pre>
<p>
Save it. Then, open a command prompt in the same directory. You&#8217;ll
want to run:
</p>
<pre>
  $ camping nuts.rb
</pre>
<p>
And you should get a message which reads:
</p>
<pre>
  ** Camping running on 0.0.0.0:3301.
</pre>
<p>
This means that right now The <a
href="../#class-Camping">Camping</a> Server is running on port 3301
on your machine. Open your browser and visit <a
href="http://localhost:3301/.">localhost:3301/.</a>
</p>
<p>
Your browser window should show:
</p>
<pre>
  Camping Problem!

  / Not found
</pre>
<p>
No problem with that. The <a href="../#class-Camping">Camping</a>
Server is running, but it doesn&#8217;t know what to show. Let&#8217;s tell
him.
</p>
<h2 class="ruled" id="hello-clock">Hello clock</h2>
<p>
So, you&#8217;ve got <a href="../#class-Camping">Camping</a>
installed and it&#8217;s running. Keep it running. You can edit files and
The <a href="../#class-Camping">Camping</a> Server will reload
automatically. When you need to stop the server, press Control-C.
</p>
<p>
Let&#8217;s show something. At the bottom of nuts.rb add:
</p>
<pre>
  module Nuts::Controllers
    class Index &lt; R '/'
      def get
        Time.now.to_s
      end
    end
  end
</pre>
<p>
Save the file and refresh the browser window. Your browser window should
show the time, e.g.
</p>
<pre>
  Sun Jul 15 12:56:15 +0200 2007
</pre>
<h2 class="ruled" id="enjoying-the-view">Enjoying the view</h2>
<p>
The <a href="../#class-Camping">Camping</a> microframework allows
us to separate our code using the MVC (Model-View-Controller) design
pattern. Let&#8217;s add a view to our Nuts application. Replace the
<tt>module Nuts::Controllers</tt> with:
</p>
<pre>
  module Nuts::Controllers
    class Index &lt; R '/'
      def get
        @time = Time.now
        render :sundial
      end
    end
  end

  module Nuts::Views
    def layout
      html do
        head do
          title { &quot;Nuts And GORP&quot; }
        end
        body { self &lt;&lt; yield }
      end
    end

    def sundial
      p &quot;The current time is: #{@time}&quot;
    end
  end
</pre>
<p>
Save the file and refresh your browser window and it should show a message
like:
</p>
<pre>
   The current time is: Sun Jul 15 13:05:41 +0200 2007
</pre>
<p>
And the window title reads &#8220;Nuts And GORP&#8221;.
</p>
<p>
Here you can see we call <tt>render :sundial</tt> from our controller. This
does exactly what it says, and renders our <tt>sundial</tt> method.
We&#8217;ve also added a special method called <tt>layout</tt> which <a
href="../#class-Camping">Camping</a> will automatically wrap our
sundial output in. If you&#8217;re familiar with HTML, you&#8217;ll see
that our view contains what looks HTML tag names. This is Markaby, which is
like writing HTML using Ruby!
</p>
<p>
Soon enough, you&#8217;ll find that you can return anything from the
controller, and it will be sent to the browser. But let&#8217;s keep that
for later and start investigating the routes.
</p>
<h2 class="ruled" id="routes">Routes</h2>
<p>
You probably noticed the weird <tt>R '/'</tt> syntax in the previous page.
This is an uncommon feature of Ruby that is used in our favorite
microframework, to describe the routes which the controller can be accessed
on.
</p>
<p>
These routes can be very powerful, but we&#8217;re going to have look at
the simplest ones first.
</p>
<pre>
  module Nuts::Controllers
    class Words &lt; R '/welcome/to/my/site'
      def get
        &quot;You got here by: /welcome/to/my/site&quot;
      end
    end

    class Digits &lt; R '/nuts/(\d+)'
      def get(number)
        &quot;You got here by: /nuts/#{number}&quot;
      end
    end

    class Segment &lt; R '/gorp/([^/]+)'
      def get(everything_else_than_a_slash)
        &quot;You got here by: /gorp/#{everything_else_than_a_slash}&quot;
      end
    end

    class DigitsAndEverything &lt; R '/nuts/(\d+)/([^/]+)'
      def get(number, everything)
        &quot;You got here by: /nuts/#{number}/#{everything}&quot;
      end
    end
  end
</pre>
<p>
Add this to nuts.rb and try if you can hit all of the controllers.
</p>
<p>
Also notice how everything inside a parenthesis gets passed into the
method, and is ready at your disposal.
</p>
<h3>Simpler routes</h3>
<p>
This just in:
</p>
<pre>
  module Nuts::Controllers
    class Index
      def get
        &quot;You got here by: /&quot;
      end
    end

    class WelcomeToMySite
      def get
        &quot;You got here by: /welcome/to/my/site&quot;
      end
    end

    class NutsN
      def get(number)
        &quot;You got here by: /nuts/#{number}&quot;
      end
    end

    class GorpX
      def get(everything_else_than_a_slash)
        &quot;You got here by: /gorp/#{everything_else_than_a_slash}&quot;
      end
    end

    class NutsNX
      def get(number, everything)
        &quot;You got here by: /nuts/#{number}/#{everything}&quot;
      end
    end
  end
</pre>
<p>
Drop the <tt>&lt; R</tt>-part and it attemps to read your mind. It
won&#8217;t always succeed, but it can simplify your application once in a
while.
</p>
<h2 class="ruled" id="modeling-the-world">Modeling the world</h2>
<p>
You can get pretty far with what you&#8217;ve learned now, and hopefully
you&#8217;ve been playing a bit off-book, but it&#8217;s time to take the
next step: Storing data.
</p>
<p>
Let&#8217;s start over again.
</p>
<pre>
  Camping.goes :Nuts

  module Nuts::Models
    class Page &lt; Base
    end
  end
</pre>
<p>
Obviously, this won&#8217;t do anything, since we don&#8217;t have any
controllers, but let&#8217;s rather have a look at we <em>do</em> have.
</p>
<p>
We have a model named Page. This means we now can store wiki pages and
retrieve them later. In fact, we can have as many models as we want. Need
one for your users and one for your blog posts? Well, I think you already
know how to do it.
</p>
<p>
However, our model is missing something essential: a skeleton.
</p>
<pre>
  Camping.goes :Nuts

  module Nuts::Models
    class Page &lt; Base
    end

    class BasicFields &lt; V 1.0
      def self.up
        create_table Page.table_name do |t|
          t.string :title
          t.text   :content
          # This gives us created_at and updated_at
          t.timestamps
        end
      end

      def self.down
        drop_table Page.table_name
      end
    end
  end
</pre>
<p>
Now we have our first version of our model. It says:
</p>
<pre>
  If you want to migrate up to version one,
    create the skeleton for the Page model,
    which should be able to store,
      &quot;title&quot; which is a string,
      &quot;content&quot; which is a larger text,
      &quot;created_at&quot; which is the time it was created,
      &quot;updated_at&quot; which is the previous time it was updated.

  If you want to migrate down from version one,
    remove the skeleton for the Page model.
</pre>
<p>
This is called a <em>migration</em>. Whenever you want to change or add new
models you simply add a new migration below, where you increase the version
number. All of these migrations builds upon each other like LEGO blocks.
</p>
<p>
Now we just need to tell <a href="../#class-Camping">Camping</a> to
use our migration. Write this at the bottom of nuts.rb
</p>
<pre>
  def Nuts.create
    Nuts::Models.create_schema
  end
</pre>
<p>
When The <a href="../#class-Camping">Camping</a> Server boots up,
it will automatically call <tt>Nuts.create</tt>. You can put all kind of
startup-code here, but right now we only want to create our skeleton (or
upgrade if needed). Start The <a
href="../#class-Camping">Camping</a> Server again and observe:
</p>
<pre>
  $ camping nuts.rb
  ** Starting Mongrel on 0.0.0.0:3301
  -- create_table(&quot;nuts_schema_infos&quot;)
     -&gt; 0.1035s
  ==  Nuts::Models::BasicFields: migrating ===================================
  -- create_table(:nuts_pages)
     -&gt; 0.0033s
  ==  Nuts::Models::BasicFields: migrated (0.0038s) ==========================
</pre>
<p>
Restart it, and enjoy the silence. There&#8217;s no point of re-creating
the skeleton this time.
</p>
<p>
Before we go on, there&#8217;s one rule you must known: Always place your
models before your migrations.
</p>
<h2 class="ruled" id="using-our-model">Using our model</h2>
<p>
Let&#8217;s explore how our model works by going into the <em>console</em>
</p>
<pre>
  $ camping -C nuts.rb
  ** Starting console
  &gt;&gt;
</pre>
<p>
Now it&#8217;s waiting for your input, and will give you the answer when
you press Enter. Here&#8217;s what I did, leaving out the boring answers.
You should add your own pages.
</p>
<pre>
  &gt;&gt; Page = Nuts::Models::Page

  &gt;&gt; hiking = Page.new(:title =&gt; &quot;Hiking&quot;)
  &gt;&gt; hiking.content = &quot;You can also set the values like this.&quot;
  &gt;&gt; hiking.save

  &gt;&gt; page = Page.find_by_title(&quot;Hiking&quot;)
  =&gt; #&lt;Nuts::Models::Page id: 1, ... &gt;
  &gt;&gt; page = Page.find(1)
  =&gt; #&lt;Nuts::Models::Page id: 1, ... &gt;
  &gt;&gt; page.title
  &gt;&gt; page.content
  &gt;&gt; page.created_at
  &gt;&gt; page.updated_at

  &gt;&gt; Page.find_by_title(&quot;Fishing&quot;)
  =&gt; nil

  ## Page.create automatically saves the page for you.
  &gt;&gt; Page.create(:title =&gt; &quot;Fishing&quot;, :content =&gt; &quot;Go fish!&quot;)

  &gt;&gt; Page.count
  =&gt; 2
</pre>
<p>
Now I have two pages: One about hiking and one about fishing.
</p>
<h2 class="ruled" id="wrapping-it-up">Wrapping it up</h2>
<p>
Wouldn&#8217;t it be nice if we could show this wonderful our pages in a
browser? Update nuts.rb so it also contains something like this:
</p>
<pre>
  module Nuts::Controllers
    class Pages
      def get
        # Only fetch the titles of the pages.
        @pages = Page.all(:select =&gt; &quot;title&quot;)
        render :list
      end
    end

    class PageX
      def get(title)
        @page = Page.find_by_title(title)
        render :view
      end
    end
  end

  module Nuts::Views
    def list
      h1 &quot;All pages&quot;
      ul do
        @pages.each do |page|
          li do
            a page.title, :href =&gt; R(PageX, page.title)
          end
        end
      end
    end

    def view
      h1 @page.title
      self &lt;&lt; @page.content
    end
  end
</pre>
<p>
Here we meet our first <em>helper</em>:
</p>
<pre>
  R(PageX, page.title)
</pre>
<p>
This is the <em>reversed router</em> and it generates a URL based on a
controller. <a href="../#class-Camping">Camping</a> ships with a
few, but very useful, helpers and you can easily add your owns. Have a look
at <a href="../#class-Camping-Helpers">Camping::Helpers</a> for how
you use these.
</p>
<p>
There&#8217;s a lot of improvements you could do here. Let me suggest:
</p>
<ul>
<li>Show when the page was created and last updated.

</li>
<li>What happens when the page doesn&#8217;t exist?

</li>
<li>What should the front page show?

</li>
<li>Add a layout.

</li>
<li>Jazz it up a bit.

</li>
</ul>
<h2 class="ruled" id="the-last-touch">The last touch</h2>
<p>
We have one major flaw in our little application. You can&#8217;t edit or
add new pages. Let&#8217;s see if we can fix that:
</p>
<pre>
  module Nuts::Controllers
    class PageX
      def get(title)
        if @page = Page.find_by_title(title)
          render :view
        else
          redirect PageXEdit, title
        end
      end

      def post(title)
        # If it doesn't exist, initialize it:
        @page = Page.find_or_initialize_by_title(title)
        # This is the same as:
        # @page = Page.find_by_title(title) || Page.new(:title =&gt; title)

        @page.content = @input.content
        @page.save
        redirect PageX, title
      end
    end

    class PageXEdit
      def get(title)
        @page = Page.find_or_initialize_by_title(title)
        render :edit
      end
    end
  end
</pre>
<p>
The core of this code lies in the new <tt>post</tt> method in the PageX
controller. When someone types an address or follows a link, they&#8217;ll
end up at the <tt>get</tt> method, but you can easily create a form which
rather sends you to the <tt>post</tt> when submitted.
</p>
<p>
There are other names you can use, but they won&#8217;t always work. So for
now, don&#8217;t be fancy and just stick to <tt>get</tt> and <tt>post</tt>.
We&#8217;ll show you how this really works later.
</p>
<p>
You might also notice that we use <tt>@input.content</tt>. The
<tt>@input</tt>-hash contains any extra parameters sent, like those in the
forms and those in the URL (<tt>/posts?page=50</tt>).
</p>
<p>
Here&#8217;s an <tt>edit</tt>-view, but you can probably do better. See if
you can integrate all of this with what you already have.
</p>
<pre>
  module Nuts::Views
    def edit
      h1 @page.title
      form :action =&gt; R(PageX, @page.title), :method =&gt; :post do
        textarea @page.content, :name =&gt; :content,
          :rows =&gt; 10, :cols =&gt; 50

        br

        input :type =&gt; :submit, :value =&gt; &quot;Submit!&quot;
      end
    end
  end
</pre>
<h2 class="ruled" id="phew">Phew.</h2>
<p>
You&#8217;ve taken quite a few steps in the last minutes. You deserve a
break. But let&#8217;s recap for a moment:
</p>
<ul>
<li>Always place <tt><a href="../#M000028">Camping.goes</a> :App</tt>
at the top of your file.

</li>
<li>Every route ends at a controller, but &#8230;

</li>
<li>&#8230; the controller only delegates the work.

</li>
<li><tt>@input</tt> contains the extra parameters.

</li>
<li>The views are HTML disguised as Ruby.

</li>
<li>They can access the instances variables (those that starts with a single
at-sign) from the controller.

</li>
<li>The models allows you to store all kinds of data.

</li>
<li>Place your models before your migrations.

</li>
<li>Helpers are helpful.

</li>
</ul>
<p>
Unfortunately, the book stops here for now. Come back in a few months, or
join the mailing list to stay updated, and hopefully there&#8217;s another
chapter waiting for you.
</p>

      </div>
    </div>
  </div>
</body>
</html>
